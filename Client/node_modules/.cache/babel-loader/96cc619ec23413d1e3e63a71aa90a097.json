{"ast":null,"code":";\n\n(function () {\n  // This would be the place to edit if you want a different\n  // Base32 implementation\n  var alphabet = '0123456789abcdefghjkmnpqrtuvwxyz';\n  var alias = {\n    o: 0,\n    i: 1,\n    l: 1,\n    s: 5\n  };\n  /**\n   * Build a lookup table and memoize it\n   *\n   * Return an object that maps a character to its\n   * byte value.\n   */\n\n  var lookup = function () {\n    var table = {}; // Invert 'alphabet'\n\n    for (var i = 0; i < alphabet.length; i++) {\n      table[alphabet[i]] = i;\n    } // Splice in 'alias'\n\n\n    for (var key in alias) {\n      if (!alias.hasOwnProperty(key)) continue;\n      table[key] = table['' + alias[key]];\n    }\n\n    lookup = function () {\n      return table;\n    };\n\n    return table;\n  };\n  /**\n   * A streaming encoder\n   *\n   *     var encoder = new base32.Encoder()\n   *     var output1 = encoder.update(input1)\n   *     var output2 = encoder.update(input2)\n   *     var lastoutput = encode.update(lastinput, true)\n   */\n\n\n  function Encoder() {\n    var skip = 0; // how many bits we will skip from the first byte\n\n    var bits = 0; // 5 high bits, carry from one byte to the next\n\n    this.output = ''; // Read one byte of input\n    // Should not really be used except by \"update\"\n\n    this.readByte = function (byte) {\n      // coerce the byte to an int\n      if (typeof byte == 'string') byte = byte.charCodeAt(0);\n\n      if (skip < 0) {\n        // we have a carry from the previous byte\n        bits |= byte >> -skip;\n      } else {\n        // no carry\n        bits = byte << skip & 248;\n      }\n\n      if (skip > 3) {\n        // not enough data to produce a character, get us another one\n        skip -= 8;\n        return 1;\n      }\n\n      if (skip < 4) {\n        // produce a character\n        this.output += alphabet[bits >> 3];\n        skip += 5;\n      }\n\n      return 0;\n    }; // Flush any remaining bits left in the stream\n\n\n    this.finish = function (check) {\n      var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '');\n      this.output = '';\n      return output;\n    };\n  }\n  /**\n   * Process additional input\n   *\n   * input: string of bytes to convert\n   * flush: boolean, should we flush any trailing bits left\n   *        in the stream\n   * returns: a string of characters representing 'input' in base32\n   */\n\n\n  Encoder.prototype.update = function (input, flush) {\n    for (var i = 0; i < input.length;) {\n      i += this.readByte(input[i]);\n    } // consume all output\n\n\n    var output = this.output;\n    this.output = '';\n\n    if (flush) {\n      output += this.finish();\n    }\n\n    return output;\n  }; // Functions analogously to Encoder\n\n\n  function Decoder() {\n    var skip = 0; // how many bits we have from the previous character\n\n    var byte = 0; // current byte we're producing\n\n    this.output = ''; // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n\n    this.readChar = function (char) {\n      if (typeof char != 'string') {\n        if (typeof char == 'number') {\n          char = String.fromCharCode(char);\n        }\n      }\n\n      char = char.toLowerCase();\n      var val = lookup()[char];\n\n      if (typeof val == 'undefined') {\n        // character does not exist in our lookup table\n        return; // skip silently. An alternative would be:\n        // throw Error('Could not find character \"' + char + '\" in lookup table.')\n      }\n\n      val <<= 3; // move to the high bits\n\n      byte |= val >>> skip;\n      skip += 5;\n\n      if (skip >= 8) {\n        // we have enough to preduce output\n        this.output += String.fromCharCode(byte);\n        skip -= 8;\n        if (skip > 0) byte = val << 5 - skip & 255;else byte = 0;\n      }\n    };\n\n    this.finish = function (check) {\n      var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '');\n      this.output = '';\n      return output;\n    };\n  }\n\n  Decoder.prototype.update = function (input, flush) {\n    for (var i = 0; i < input.length; i++) {\n      this.readChar(input[i]);\n    }\n\n    var output = this.output;\n    this.output = '';\n\n    if (flush) {\n      output += this.finish();\n    }\n\n    return output;\n  };\n  /** Convenience functions\n   *\n   * These are the ones to use if you just have a string and\n   * want to convert it without dealing with streams and whatnot.\n   */\n  // String of data goes in, Base32-encoded string comes out.\n\n\n  function encode(input) {\n    var encoder = new Encoder();\n    var output = encoder.update(input, true);\n    return output;\n  } // Base32-encoded string goes in, decoded data comes out.\n\n\n  function decode(input) {\n    var decoder = new Decoder();\n    var output = decoder.update(input, true);\n    return output;\n  }\n  /**\n   * sha1 functions wrap the hash function from Node.js\n   *\n   * Several ways to use this:\n   *\n   *     var hash = base32.sha1('Hello World')\n   *     base32.sha1(process.stdin, function (err, data) {\n   *       if (err) return console.log(\"Something went wrong: \" + err.message)\n   *       console.log(\"Your SHA1: \" + data)\n   *     }\n   *     base32.sha1.file('/my/file/path', console.log)\n   */\n\n\n  var crypto, fs;\n\n  function sha1(input, cb) {\n    if (typeof crypto == 'undefined') crypto = require('crypto');\n    var hash = crypto.createHash('sha1');\n\n    hash.digest = function (digest) {\n      return function () {\n        return encode(digest.call(this, 'binary'));\n      };\n    }(hash.digest);\n\n    if (cb) {\n      // streaming\n      if (typeof input == 'string' || Buffer.isBuffer(input)) {\n        try {\n          return cb(null, sha1(input));\n        } catch (err) {\n          return cb(err, null);\n        }\n      }\n\n      if (!typeof input.on == 'function') return cb({\n        message: \"Not a stream!\"\n      });\n      input.on('data', function (chunk) {\n        hash.update(chunk);\n      });\n      input.on('end', function () {\n        cb(null, hash.digest());\n      });\n      return;\n    } // non-streaming\n\n\n    if (input) {\n      return hash.update(input).digest();\n    }\n\n    return hash;\n  }\n\n  sha1.file = function (filename, cb) {\n    if (filename == '-') {\n      process.stdin.resume();\n      return sha1(process.stdin, cb);\n    }\n\n    if (typeof fs == 'undefined') fs = require('fs');\n    return fs.stat(filename, function (err, stats) {\n      if (err) return cb(err, null);\n      if (stats.isDirectory()) return cb({\n        dir: true,\n        message: \"Is a directory\"\n      });\n      return sha1(require('fs').createReadStream(filename), cb);\n    });\n  };\n\n  var base32 = {\n    Decoder: Decoder,\n    Encoder: Encoder,\n    encode: encode,\n    decode: decode,\n    sha1: sha1\n  };\n\n  if (typeof window !== 'undefined') {\n    // we're in a browser - OMG!\n    window.base32 = base32;\n  }\n\n  if (typeof module !== 'undefined' && module.exports) {\n    // nodejs/browserify\n    module.exports = base32;\n  }\n})();","map":{"version":3,"sources":["/Users/yuhojin/Desktop/BEB1stProject-05/Client/node_modules/base32/lib/base32.js"],"names":["alphabet","alias","o","i","l","s","lookup","table","length","key","hasOwnProperty","Encoder","skip","bits","output","readByte","byte","charCodeAt","finish","check","prototype","update","input","flush","Decoder","readChar","char","String","fromCharCode","toLowerCase","val","encode","encoder","decode","decoder","crypto","fs","sha1","cb","require","hash","createHash","digest","call","Buffer","isBuffer","err","on","message","chunk","file","filename","process","stdin","resume","stat","stats","isDirectory","dir","createReadStream","base32","window","module","exports"],"mappings":"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","sourcesContent":[";(function(){\n\n// This would be the place to edit if you want a different\n// Base32 implementation\n\nvar alphabet = '0123456789abcdefghjkmnpqrtuvwxyz'\nvar alias = { o:0, i:1, l:1, s:5 }\n\n/**\n * Build a lookup table and memoize it\n *\n * Return an object that maps a character to its\n * byte value.\n */\n\nvar lookup = function() {\n    var table = {}\n    // Invert 'alphabet'\n    for (var i = 0; i < alphabet.length; i++) {\n        table[alphabet[i]] = i\n    }\n    // Splice in 'alias'\n    for (var key in alias) {\n        if (!alias.hasOwnProperty(key)) continue\n        table[key] = table['' + alias[key]]\n    }\n    lookup = function() { return table }\n    return table\n}\n\n/**\n * A streaming encoder\n *\n *     var encoder = new base32.Encoder()\n *     var output1 = encoder.update(input1)\n *     var output2 = encoder.update(input2)\n *     var lastoutput = encode.update(lastinput, true)\n */\n\nfunction Encoder() {\n    var skip = 0 // how many bits we will skip from the first byte\n    var bits = 0 // 5 high bits, carry from one byte to the next\n\n    this.output = ''\n\n    // Read one byte of input\n    // Should not really be used except by \"update\"\n    this.readByte = function(byte) {\n        // coerce the byte to an int\n        if (typeof byte == 'string') byte = byte.charCodeAt(0)\n\n        if (skip < 0) { // we have a carry from the previous byte\n            bits |= (byte >> (-skip))\n        } else { // no carry\n            bits = (byte << skip) & 248\n        }\n\n        if (skip > 3) {\n            // not enough data to produce a character, get us another one\n            skip -= 8\n            return 1\n        }\n\n        if (skip < 4) {\n            // produce a character\n            this.output += alphabet[bits >> 3]\n            skip += 5\n        }\n\n        return 0\n    }\n\n    // Flush any remaining bits left in the stream\n    this.finish = function(check) {\n        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '')\n        this.output = ''\n        return output\n    }\n}\n\n/**\n * Process additional input\n *\n * input: string of bytes to convert\n * flush: boolean, should we flush any trailing bits left\n *        in the stream\n * returns: a string of characters representing 'input' in base32\n */\n\nEncoder.prototype.update = function(input, flush) {\n    for (var i = 0; i < input.length; ) {\n        i += this.readByte(input[i])\n    }\n    // consume all output\n    var output = this.output\n    this.output = ''\n    if (flush) {\n      output += this.finish()\n    }\n    return output\n}\n\n// Functions analogously to Encoder\n\nfunction Decoder() {\n    var skip = 0 // how many bits we have from the previous character\n    var byte = 0 // current byte we're producing\n\n    this.output = ''\n\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    this.readChar = function(char) {\n        if (typeof char != 'string'){\n            if (typeof char == 'number') {\n                char = String.fromCharCode(char)\n            }\n        }\n        char = char.toLowerCase()\n        var val = lookup()[char]\n        if (typeof val == 'undefined') {\n            // character does not exist in our lookup table\n            return // skip silently. An alternative would be:\n            // throw Error('Could not find character \"' + char + '\" in lookup table.')\n        }\n        val <<= 3 // move to the high bits\n        byte |= val >>> skip\n        skip += 5\n        if (skip >= 8) {\n            // we have enough to preduce output\n            this.output += String.fromCharCode(byte)\n            skip -= 8\n            if (skip > 0) byte = (val << (5 - skip)) & 255\n            else byte = 0\n        }\n\n    }\n\n    this.finish = function(check) {\n        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '')\n        this.output = ''\n        return output\n    }\n}\n\nDecoder.prototype.update = function(input, flush) {\n    for (var i = 0; i < input.length; i++) {\n        this.readChar(input[i])\n    }\n    var output = this.output\n    this.output = ''\n    if (flush) {\n      output += this.finish()\n    }\n    return output\n}\n\n/** Convenience functions\n *\n * These are the ones to use if you just have a string and\n * want to convert it without dealing with streams and whatnot.\n */\n\n// String of data goes in, Base32-encoded string comes out.\nfunction encode(input) {\n  var encoder = new Encoder()\n  var output = encoder.update(input, true)\n  return output\n}\n\n// Base32-encoded string goes in, decoded data comes out.\nfunction decode(input) {\n    var decoder = new Decoder()\n    var output = decoder.update(input, true)\n    return output\n}\n\n/**\n * sha1 functions wrap the hash function from Node.js\n *\n * Several ways to use this:\n *\n *     var hash = base32.sha1('Hello World')\n *     base32.sha1(process.stdin, function (err, data) {\n *       if (err) return console.log(\"Something went wrong: \" + err.message)\n *       console.log(\"Your SHA1: \" + data)\n *     }\n *     base32.sha1.file('/my/file/path', console.log)\n */\n\nvar crypto, fs\nfunction sha1(input, cb) {\n    if (typeof crypto == 'undefined') crypto = require('crypto')\n    var hash = crypto.createHash('sha1')\n    hash.digest = (function(digest) {\n        return function() {\n            return encode(digest.call(this, 'binary'))\n        }\n    })(hash.digest)\n    if (cb) { // streaming\n        if (typeof input == 'string' || Buffer.isBuffer(input)) {\n            try {\n                return cb(null, sha1(input))\n            } catch (err) {\n                return cb(err, null)\n            }\n        }\n        if (!typeof input.on == 'function') return cb({ message: \"Not a stream!\" })\n        input.on('data', function(chunk) { hash.update(chunk) })\n        input.on('end', function() { cb(null, hash.digest()) })\n        return\n    }\n\n    // non-streaming\n    if (input) {\n        return hash.update(input).digest()\n    }\n    return hash\n}\nsha1.file = function(filename, cb) {\n    if (filename == '-') {\n        process.stdin.resume()\n        return sha1(process.stdin, cb)\n    }\n    if (typeof fs == 'undefined') fs = require('fs')\n    return fs.stat(filename, function(err, stats) {\n        if (err) return cb(err, null)\n        if (stats.isDirectory()) return cb({ dir: true, message: \"Is a directory\" })\n        return sha1(require('fs').createReadStream(filename), cb)\n    })\n}\n\nvar base32 = {\n    Decoder: Decoder,\n    Encoder: Encoder,\n    encode: encode,\n    decode: decode,\n    sha1: sha1\n}\n\nif (typeof window !== 'undefined') {\n  // we're in a browser - OMG!\n  window.base32 = base32\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  // nodejs/browserify\n  module.exports = base32\n}\n})();\n"]},"metadata":{},"sourceType":"script"}